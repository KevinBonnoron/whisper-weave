import type { Components } from 'react-markdown';
import { useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import type { BundledLanguage, Highlighter } from 'shiki';
import { createHighlighter } from 'shiki';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

const listClassName = 'my-2 list-inside list-disc space-y-0.5 pl-4';
const headingClassName = 'mt-3 font-semibold first:mt-0';

// Singleton highlighter instance
let highlighterPromise: Promise<Highlighter> | null = null;
const loadedLanguages = new Set<string>(['text']);

function getHighlighter(): Promise<Highlighter> {
  if (!highlighterPromise) {
    highlighterPromise = createHighlighter({
      themes: ['github-dark'],
      langs: [], // Start with no languages, load on demand
    });
  }
  return highlighterPromise;
}

async function highlightCode(code: string, lang: string): Promise<string> {
  const highlighter = await getHighlighter();
  const normalizedLang = lang.toLowerCase() === 'yml' ? 'yaml' : lang.toLowerCase();

  // Load language if not already loaded
  if (!loadedLanguages.has(normalizedLang)) {
    try {
      await highlighter.loadLanguage(normalizedLang as BundledLanguage);
      loadedLanguages.add(normalizedLang);
    } catch {
      // Language not supported, fall back to text
      return highlighter.codeToHtml(code, { lang: 'text', theme: 'github-dark' });
    }
  }

  return highlighter.codeToHtml(code, { lang: normalizedLang, theme: 'github-dark' });
}

function CodeBlock({ code, lang }: { code: string; lang: string | undefined }) {
  const { t } = useTranslation();
  const [copied, setCopied] = useState(false);
  const [html, setHtml] = useState<string | null>(null);

  useEffect(() => {
    highlightCode(code, lang || 'text').then(setHtml);
  }, [code, lang]);

  const handleCopy = async () => {
    await navigator.clipboard.writeText(code);
    setCopied(true);
    setTimeout(() => setCopied(false), 1500);
  };

  return (
    <div className="group relative my-2">
      <Button
        type="button"
        variant="outline"
        size="xs"
        className="text-muted-foreground hover:text-foreground absolute right-2 top-2 z-10 border-transparent bg-black/20 opacity-0 transition-opacity focus:opacity-100 group-hover:opacity-100 dark:bg-white/20"
        onClick={handleCopy}
        title={copied ? t('ConversationChat.copiedCode') : t('ConversationChat.copyCode')}
      >
        {copied ? t('ConversationChat.copiedCode') : t('ConversationChat.copyCode')}
      </Button>
      {html ? (
        <div
          className="[&>pre]:overflow-x-auto [&>pre]:rounded-md [&>pre]:p-4 [&>pre]:text-[0.8125rem] [&_code]:font-mono"
          // biome-ignore lint/security/noDangerouslySetInnerHtml: HTML is generated by shiki, not user input
          dangerouslySetInnerHTML={{ __html: html }}
        />
      ) : (
        <pre className="overflow-x-auto rounded-md bg-[#24292e] p-4 text-[0.8125rem]">
          <code className="font-mono text-gray-300">{code}</code>
        </pre>
      )}
    </div>
  );
}

const components: Components = {
  p: ({ children }) => <p className="my-1.5 leading-relaxed [&:first-child]:mt-0 [&:last-child]:mb-0">{children}</p>,
  ul: ({ children }) => <ul className={listClassName}>{children}</ul>,
  ol: ({ children }) => <ol className={cn(listClassName, 'list-decimal')}>{children}</ol>,
  strong: ({ children }) => <strong className="font-semibold">{children}</strong>,
  a: ({ href, children }) => (
    <Button variant="link" asChild className="h-auto p-0 text-inherit underline hover:opacity-80">
      <a href={href} target="_blank" rel="noopener noreferrer">
        {children}
      </a>
    </Button>
  ),
  h1: ({ children }) => <h1 className={cn(headingClassName, 'text-lg')}>{children}</h1>,
  h2: ({ children }) => <h2 className={cn(headingClassName, 'text-base')}>{children}</h2>,
  h3: ({ children }) => <h3 className={cn(headingClassName, 'text-sm')}>{children}</h3>,
  code({ className, children, ...props }) {
    const match = /language-(\w+)/.exec(className ?? '');
    const lang = match?.[1];
    const codeString = String(children).replace(/\n$/, '');
    const isBlock = Boolean(className && match);

    if (isBlock) {
      return <CodeBlock code={codeString} lang={lang} />;
    }

    return (
      <code className="rounded bg-black/20 px-1 py-0.5 font-mono text-xs dark:bg-white/20" {...props}>
        {children}
      </code>
    );
  },
};

type MarkdownContentProps = {
  content: string;
  className?: string;
};

export function MarkdownContent({ content, className }: MarkdownContentProps) {
  return (
    <div className={className}>
      <ReactMarkdown remarkPlugins={[remarkGfm]} components={components}>
        {content}
      </ReactMarkdown>
    </div>
  );
}
